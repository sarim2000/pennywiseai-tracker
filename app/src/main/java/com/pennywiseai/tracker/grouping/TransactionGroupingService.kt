package com.pennywiseai.tracker.grouping

import com.pennywiseai.tracker.data.Transaction
import com.pennywiseai.tracker.data.TransactionGroup
import com.pennywiseai.tracker.data.GroupingType
import com.pennywiseai.tracker.repository.TransactionGroupRepository
import com.pennywiseai.tracker.repository.TransactionRepository
import android.util.Log
import kotlinx.coroutines.flow.first

class TransactionGroupingService(
    private val groupRepository: TransactionGroupRepository,
    private val transactionRepository: TransactionRepository,
    private val database: com.pennywiseai.tracker.database.AppDatabase
) {
    
    companion object {
        private const val TAG = "TransactionGroupingService"
        private const val MIN_TRANSACTIONS_FOR_GROUP = 2
        private const val MIN_WORD_LENGTH = 3
        private const val CONFIDENCE_MERCHANT_WORD = 0.9f
    }
    
    /**
     * Auto-group ungrouped transactions using word-based merchant matching
     */
    suspend fun autoGroupTransactions() {
        Log.i(TAG, "ü§ñ Starting automatic transaction grouping...")
        
        val ungroupedTransactions = groupRepository.getUngroupedTransactions(500)
        
        if (ungroupedTransactions.isEmpty()) {
            return
        }
        
        // Group by merchant words
        groupByMerchantWords(ungroupedTransactions)
        
        // Refresh all group totals
        refreshAllGroupTotals()
        
        // Clean up empty groups
        cleanupEmptyGroups()
        
        Log.i(TAG, "‚úÖ Automatic grouping completed")
    }
    
    /**
     * Group transactions by common words in merchant names
     */
    private suspend fun groupByMerchantWords(transactions: List<Transaction>) {
        val processedTransactions = mutableSetOf<String>()
        
        // Load manual grouping history once
        val manualMappings = database.transactionGroupDao().getAllManualMappings()
        
        for (transaction in transactions) {
            if (transaction.id in processedTransactions) continue
            
            val words = extractWords(transaction.merchant)
            if (words.isEmpty()) {
                continue
            }
            
            // First, check if any word matches manual grouping history
            val manualGroupId = findManuallyAssignedGroup(words, manualMappings)
            if (manualGroupId != null) {
                try {
                    // Check if transaction is already grouped
                    val existingMappings = groupRepository.getMappingsForTransaction(transaction.id)
                    if (existingMappings.isEmpty()) {
                        groupRepository.addTransactionToGroup(
                            transactionId = transaction.id,
                            groupId = manualGroupId,
                            confidence = 0.95f, // High confidence from user learning
                            isManual = false
                        )
                        processedTransactions.add(transaction.id)
                    }
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Failed to add to learned group: ${e.message}")
                }
                continue
            }
            
            // If no manual pattern found, proceed with normal grouping
            // Find all transactions that share at least one word
            val similarTransactions = transactions.filter { other ->
                other.id !in processedTransactions && 
                extractWords(other.merchant).intersect(words).isNotEmpty()
            }
            
            if (similarTransactions.size < MIN_TRANSACTIONS_FOR_GROUP) {
                continue
            }
            
            
            // Find the most common word to use as group name
            val allWords = similarTransactions.flatMap { extractWords(it.merchant) }
            val mostCommonWord = allWords.groupingBy { it }.eachCount()
                .maxByOrNull { it.value }?.key ?: transaction.merchant
            
            // Check if group already exists
            val existingGroup = groupRepository.getGroupByPattern(mostCommonWord, GroupingType.MERCHANT_EXACT)
            
            val group = if (existingGroup != null) {
                existingGroup
            } else {
                // Create new group
                val newGroup = groupRepository.createGroup(
                    name = "$mostCommonWord (${similarTransactions.size} transactions)",
                    merchantPattern = mostCommonWord,
                    category = similarTransactions.first().category,
                    groupingType = GroupingType.MERCHANT_EXACT,
                    isAutoGenerated = true
                )
                newGroup
            }
            
            // Add transactions to group
            var addedCount = 0
            for (txn in similarTransactions) {
                try {
                    // Check if transaction is already in any group
                    val existingMappings = groupRepository.getMappingsForTransaction(txn.id)
                    if (existingMappings.isEmpty()) {
                        groupRepository.addTransactionToGroup(
                            transactionId = txn.id,
                            groupId = group.id,
                            confidence = CONFIDENCE_MERCHANT_WORD,
                            isManual = false
                        )
                        processedTransactions.add(txn.id)
                        addedCount++
                    }
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Failed to add transaction ${txn.id}: ${e.message}")
                }
            }
            
        }
    }
    
    /**
     * Find if any word from merchant was manually grouped before
     */
    private suspend fun findManuallyAssignedGroup(
        merchantWords: Set<String>,
        manualMappings: List<com.pennywiseai.tracker.data.TransactionGroupMapping>
    ): String? {
        for (mapping in manualMappings) {
            // Get the transaction that was manually grouped
            val transaction = transactionRepository.getTransactionByIdSync(mapping.transactionId)
            if (transaction != null) {
                val transactionWords = extractWords(transaction.merchant)
                // Check if any word matches
                if (transactionWords.intersect(merchantWords).isNotEmpty()) {
                    return mapping.groupId
                }
            }
        }
        return null
    }
    
    /**
     * Extract significant words from merchant name
     */
    private fun extractWords(merchant: String): Set<String> {
        // Words to exclude from grouping
        val excludeWords = setOf("UNKNOWN", "MERCHANT", "TRANSACTION", "PAYMENT")
        
        return merchant
            .uppercase()
            .split(" ", "-", "_", "*", "@", ".", "/", "\\", ",", ":", ";", "(", ")", "[", "]", "{", "}")
            .asSequence()
            .map { it.trim() }
            .filter { word -> 
                word.length >= MIN_WORD_LENGTH && 
                !word.all { char -> char.isDigit() } && // Not just numbers
                word !in excludeWords // Not excluded words
            }
            .toSet()
    }
    
    /**
     * Group a single transaction (for new transactions)
     */
    suspend fun groupTransaction(transaction: Transaction, forceRegroup: Boolean = false) {
        if (!forceRegroup) {
            // Check if already grouped
            val existingMappings = groupRepository.getMappingsForTransaction(transaction.id)
            if (existingMappings.isNotEmpty()) {
                return
            }
        }
        
        // Extract words from merchant name
        val words = extractWords(transaction.merchant)
        if (words.isEmpty()) {
            return
        }
        
        // Try to find existing group with matching word
        for (word in words) {
            val existingGroup = groupRepository.getGroupByPattern(word, GroupingType.MERCHANT_EXACT)
            if (existingGroup != null) {
                groupRepository.addTransactionToGroup(
                    transactionId = transaction.id,
                    groupId = existingGroup.id,
                    confidence = CONFIDENCE_MERCHANT_WORD,
                    isManual = false
                )
                return
            }
        }
        
        // Check if we can create a new group with other similar transactions
        val allTransactions = transactionRepository.getAllTransactions().first()
        val similarTransactions = allTransactions.filter { other ->
            other.id != transaction.id &&
            extractWords(other.merchant).intersect(words).isNotEmpty()
        }
        
        if (similarTransactions.size >= MIN_TRANSACTIONS_FOR_GROUP - 1) { // -1 because we include current transaction
            autoGroupTransactions() // This will handle the grouping
        } else {
        }
    }
    
    /**
     * Refresh all group totals to ensure cached counts match actual mappings
     */
    private suspend fun refreshAllGroupTotals() {
        try {
            val groups = groupRepository.getAllActiveGroups().first()
            
            for (group in groups) {
                groupRepository.updateGroupTotals(group.id)
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Failed to refresh group totals: ${e.message}", e)
        }
    }
    
    /**
     * Clean up empty groups (groups with no transactions)
     */
    private suspend fun cleanupEmptyGroups() {
        try {
            val groups = groupRepository.getAllActiveGroups().first()
            
            var deletedCount = 0
            for (group in groups) {
                val transactionCount = groupRepository.getRecentTransactionsForGroup(group.id, 1).size
                if (transactionCount == 0) {
                    groupRepository.deleteGroup(group)
                    deletedCount++
                }
            }
            
            if (deletedCount > 0) {
            } else {
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Failed to cleanup empty groups: ${e.message}", e)
        }
    }
}