package com.pennywiseai.tracker.database

import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import android.content.Context
import com.pennywiseai.tracker.data.Transaction
import com.pennywiseai.tracker.data.Subscription
import com.pennywiseai.tracker.data.AppSettings
import com.pennywiseai.tracker.data.TransactionGroup
import com.pennywiseai.tracker.data.TransactionGroupMapping

@Database(
    entities = [Transaction::class, Subscription::class, AppSettings::class, TransactionGroup::class, TransactionGroupMapping::class],
    version = 6,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    
    abstract fun transactionDao(): TransactionDao
    abstract fun subscriptionDao(): SubscriptionDao
    abstract fun settingsDao(): SettingsDao
    abstract fun transactionGroupDao(): TransactionGroupDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        // Migration from version 1 to 2: Add transactionType column
        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Add transactionType column with default value UNKNOWN
                db.execSQL(
                    "ALTER TABLE transactions ADD COLUMN transactionType TEXT NOT NULL DEFAULT 'UNKNOWN'"
                )
                
                // Update existing records: convert isSubscription to transactionType
                db.execSQL(
                    "UPDATE transactions SET transactionType = 'SUBSCRIPTION' WHERE isSubscription = 1"
                )
                db.execSQL(
                    "UPDATE transactions SET transactionType = 'ONE_TIME' WHERE isSubscription = 0"
                )
            }
        }
        
        // Migration from version 2 to 3: Enhance Subscription model with lifecycle fields
        val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Add new lifecycle columns to subscriptions table
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN startDate INTEGER NOT NULL DEFAULT 0")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN endDate INTEGER")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN cancellationDate INTEGER")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN status TEXT NOT NULL DEFAULT 'ACTIVE'")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN category TEXT NOT NULL DEFAULT 'SUBSCRIPTION'")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN description TEXT")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN paymentCount INTEGER NOT NULL DEFAULT 0")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN totalPaid REAL NOT NULL DEFAULT 0.0")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN lastAmountPaid REAL NOT NULL DEFAULT 0.0")
                db.execSQL("ALTER TABLE subscriptions ADD COLUMN averageAmount REAL NOT NULL DEFAULT 0.0")
                
                // Update existing records with calculated values
                db.execSQL("UPDATE subscriptions SET startDate = lastPaymentDate WHERE startDate = 0")
                db.execSQL("UPDATE subscriptions SET lastAmountPaid = amount WHERE lastAmountPaid = 0.0")
                db.execSQL("UPDATE subscriptions SET averageAmount = amount WHERE averageAmount = 0.0")
                
                // Synchronize status and active fields for existing data
                db.execSQL("UPDATE subscriptions SET status = 'ACTIVE' WHERE active = 1")
                db.execSQL("UPDATE subscriptions SET status = 'CANCELLED' WHERE active = 0")
                db.execSQL("UPDATE subscriptions SET active = 1 WHERE status = 'ACTIVE'")
                db.execSQL("UPDATE subscriptions SET active = 0 WHERE status != 'ACTIVE'")
            }
        }
        
        // Migration from version 3 to 4: Add TransactionGroup and TransactionGroupMapping tables
        val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Create transaction_groups table
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `transaction_groups` (
                        `id` TEXT NOT NULL,
                        `name` TEXT NOT NULL,
                        `merchantPattern` TEXT NOT NULL,
                        `category` TEXT NOT NULL,
                        `groupingType` TEXT NOT NULL,
                        `isAutoGenerated` INTEGER NOT NULL,
                        `createdDate` INTEGER NOT NULL,
                        `lastUpdated` INTEGER NOT NULL,
                        `transactionCount` INTEGER NOT NULL DEFAULT 0,
                        `totalAmount` REAL NOT NULL DEFAULT 0.0,
                        `averageAmount` REAL NOT NULL DEFAULT 0.0,
                        `lastTransactionDate` INTEGER NOT NULL DEFAULT 0,
                        `isActive` INTEGER NOT NULL DEFAULT 1,
                        PRIMARY KEY(`id`)
                    )
                """)
                
                // Create transaction_group_mappings table
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `transaction_group_mappings` (
                        `id` TEXT NOT NULL,
                        `transactionId` TEXT NOT NULL,
                        `groupId` TEXT NOT NULL,
                        `confidence` REAL NOT NULL,
                        `createdDate` INTEGER NOT NULL,
                        `isManuallyAssigned` INTEGER NOT NULL DEFAULT 0,
                        PRIMARY KEY(`id`),
                        FOREIGN KEY(`transactionId`) REFERENCES `transactions`(`id`) ON DELETE CASCADE,
                        FOREIGN KEY(`groupId`) REFERENCES `transaction_groups`(`id`) ON DELETE CASCADE
                    )
                """)
                
                // Create indices for better performance
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_transaction_group_mappings_transactionId` ON `transaction_group_mappings` (`transactionId`)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_transaction_group_mappings_groupId` ON `transaction_group_mappings` (`groupId`)")
                db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_transaction_group_mappings_transactionId_groupId` ON `transaction_group_mappings` (`transactionId`, `groupId`)")
            }
        }
        
        // Migration from version 4 to 5: Add onboarding fields to AppSettings
        val MIGRATION_4_5 = object : Migration(4, 5) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Add onboarding tracking columns to app_settings table
                db.execSQL("ALTER TABLE app_settings ADD COLUMN hasCompletedOnboarding INTEGER NOT NULL DEFAULT 0")
                db.execSQL("ALTER TABLE app_settings ADD COLUMN onboardingCompletedAt INTEGER NOT NULL DEFAULT 0")
            }
        }
        
        // Migration from version 5 to 6: Add sender column to transactions
        val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Add sender column to transactions table
                db.execSQL("ALTER TABLE transactions ADD COLUMN sender TEXT")
            }
        }
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "transaction_tracker_database"
                )
                .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5, MIGRATION_5_6)
                .fallbackToDestructiveMigration()
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}